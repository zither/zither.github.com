<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title><![CDATA[MiniThinker]]></title>
	<subtitle>努力学习那些想要知道的东西</subtitle>
	<link href="http://blog.shouhuiben.net/atom.xml" rel="self" />
	<link href="http://blog.shouhuiben.net/" />
	<id>urn:uuid:383ccd36-a683-4898-15fd-9525d3a970f7</id>
	<updated>2015-02-15T10:28:58+08:00</updated>
	<author>
		<name><![CDATA[Minimee]]></name>
		<uri>http://blog.shouhuiben.net/</uri>
	</author>
	<entry>
		<title type="html"><![CDATA[Skcoswodahs client 的简单实现]]></title>
		<link href="http://blog.shouhuiben.net/article/2015/02/12/a-simple-implemention-of-Skcoswodahs-client" />
		<id>urn:uuid:68e26d71-89af-f9dd-ce16-a31d8948d2d7</id>
		<updated>2015-02-12T15:05:02+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;现在最热门的上网姿势非 &lt;a href=&quot;https://github.com/shadowsocks/shadowsocks&quot;&gt;Skcoswodahs&lt;/a&gt; 莫属，当初作者发布的时候只是一个非常简单的小工具，但是没想到现在基本达到了全平台覆盖。可能有不少朋友对它的原理感兴趣，这里就让我们使用 PHP 来实现一个简单的 Skcoswodahs 客户端。&lt;/p&gt;
&lt;p&gt;首先我们需要知道 Skcoswodahs 在传输数据的时候是分为3个部分，这里我们使用浏览器访问网站的例子来说明：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+--------------------------------------------------------------+
|             1                2                 3             |
+  browser ------- ss-local ------- ss-server ------- DST host +
|           socks         Skcoswodahs          socks           |
+--------------------------------------------------------------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面我们可以看出，shadowsock 将一个 SOCKS 代理拆分为 local SOCKS（1） 以及 server SOCKS（3） 两个代理，这两个阶段传递的都是原始数据。而 local SOCKS 与 server SOCKS 之间（2）传输的则是经过加密的数据，我们暂且称其为 Skcoswodahs 协议。&lt;/p&gt;
&lt;p&gt;在这篇文章中我们要实现的就是 ss-local，它负责接收浏览器发出的 HTTP 请求，然后将请求内容加密后转发到 ss-server。不过为了方便这里我们跳过了 ss-local 与浏览器 SOCKS 握手的 method-dependent 阶段，直接纯手工构建需要传输的数据。如果你并不了解 SOCKS 协议，那么需要先阅读 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1928.txt&quot;&gt;SOCKS 协议规范&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在浏览器与 ss-local 之间的 method-dependent 协商完成后，浏览器会将需要访问的服务器地址和端口发送给 ss-local，其格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; +----+-----+-------+------+----------+----------+
 |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
 +----+-----+-------+------+----------+----------+
 | 1  |  1  | X&#039;00&#039; |  1   | Variable |    2     |
 +----+-----+-------+------+----------+----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ATYP，DST.ADDR 和 DST.PORT 这三个字段（Header）是需要通过我们的客户端转发到 ss-server 的。在我们与 ss-server 连接成功后可以完成与浏览器 SOCKS 协商的剩下部分。浏览器再将 HTTP 请求发送到我们的客户端。我们可以直接将之前的 Header 和 HTTP 请求内容拼接在一起进行加密，然后通过之前建立的连接发送的 ss-server。加密数据的格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; +------+----------+----------+----------+
 | ATYP | DST.ADDR | DST.PORT |   HTTP   | 
 +------+----------+----------+----------+
 |  1   | Variable |    2     | Variable |
 +------+----------+----------+----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，header 部分只需要在建立通道的时候发送一次，通道建立之后直接传递加密的请求数据即可。ss-server 在收到数据后会直接解密，读取 ATYP 字段，根据其类型解析 header 部分，如果数据的整个长度超过 header 的长度，剩下的部分就会作为请求的内容。ss-server 会将从目标服务器获取的数据加密后通过通道转发回我们的客户端，我们需要将数据解密后返回给浏览器。&lt;/p&gt;
&lt;p&gt;从整个通信过程来说，我们的客户端其实就是带有加密解密功能的 SOCKS server。除了 SOCKS server 最基本的功能以外，需要我们动手就是加密解密功能了。现在我们开始写代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;//source code: https://gist.github.com/zither/e35888cbb98e56f59dd4
require &quot;Encryptor.php&quot;;
require &quot;Cipher.php&quot;;
require &quot;Rc4crypt.php&quot;;

$domain = &quot;www.google.com&quot;;
$data = pack(&quot;C2&quot;, 0x03, strlen($domain));
$data .= $domain . pack(&quot;n&quot;, 0x50);
$data .= sprintf(&quot;GET / HTTP/1.1\r\nHost:%s\r\nAccept:text/html\r\n\r\n&quot;, $domain);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的客户端非常简单，简单到只支持一直加密方式：RC4。Encryptor.php，Cipher.php 和 Rc4crypt.php 这三个文件功能比较简单。Rc4crypt 提供了 RC4 加密方法的原生实现，Cipher 只是对 Rc4crypt 包裹了一下，实现了 Skcoswodahs 使用的 RC4-md5 加密，其实就是每个请求使用不同的 key 而已。Encryptor 的主要作用有两个：一是通过 password 生成加密需要的 key 和 随机 iv 字符串，二是调用 Cipher 对数据进行加密和解密。&lt;/p&gt;
&lt;p&gt;我直接跳过了与浏览器协商的部分，我们假设浏览器发出的请求是访问 Google 首页，为了摆出科学的姿势，我们不能在本地对 Domain 进行 DNS 解析，所以 Header 的内容是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; +------+------+----------------+----------+
 | ATYP | ALEN |    DST.ADDR    | DST.PORT | 
 +------+------+----------------+----------+
 | 0x03 | 0x0E | www.google.com |   0x50   |
 +------+------+----------------+----------+&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面表示的是 ATYP 为完整域名（0x03）时的格式，ALEN 用一个字节指定域名的长度，DST.PORT 用两个字节指定端口。SOCKS 还支持 IP4（0x01）和 IP6（0x04），对应的格式可以直接在 &lt;a href=&quot;https://www.ietf.org/rfc/rfc1928.txt&quot;&gt;SOCKS 协议规范&lt;/a&gt;中了解。为了避免 ss-server 在解析 Header 时出现错误，ATYP,ALEN 以及 DST.PORT 这几个重要的部分我们通过 pack 函数以二进制的形式包装到字符串中。最后我们在 Header 后面附加一个简单的 HTTP 请求，这样我们就完成了一个虚拟请求的数据构成。&lt;/p&gt;
&lt;p&gt;现在我们可以将数据进行加密了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$encryptor = new Encryptor(&quot;password&quot;, &quot;RC4&quot;);
$encryptedData = $encryptor-&amp;gt;encrypt($data);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的 password 就是 Skcoswodahs 的配置文件中约定的密码，RC4 是加密方法。这里有一个地方需要注意，在第一次加密数据的时候 Encryptor 会将随机字符串 iv 与我们的数据拼接在一起：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;class Encryptor 
{
    //...
    public function encrypt($data)
    {
        if (strlen($data) == 0) {
            return $data;
        }
        if ($this-&amp;gt;ivSent) {
            return $this-&amp;gt;cipher-&amp;gt;encrypt($data);
        }
        $this-&amp;gt;ivSent = true;
        return $this-&amp;gt;cipherIv . $this-&amp;gt;cipher-&amp;gt;encrypt($data);
    }
    //...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我们准备好数据之后就要开始与 ss-server 通信，如果你手上没有 Skcoswodahs 服务器，可以在本地环境中搭建一个，server 地址改为 127.0.0.1 就可以了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
    &quot;server&quot;: &quot;127.0.0.1&quot;,
    &quot;server_port&quot;: &quot;50560&quot;,
    &quot;local_address&quot;: &quot;127.0.0.1&quot;,
    &quot;local_port&quot;: &quot;5250&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;timeout&quot;: &quot;300&quot;,
    &quot;method&quot;: &quot;rc4-md5&quot;,
    &quot;fast_open&quot;: false,
    &quot;workers&quot;: 1
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你使用的是本地服务器，请将前面代码中的 domain 换为国内能够访问的地址，比如 www.bing.com。数据加密之后我们需要与 ss-server 建立一个通道：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$remote = stream_socket_client(&quot;tcp://example.ss-server.com:50565&quot;, $errno, $errstr);
if (!$remote) {
    throw new Exception($errstr, $errno);
}
$send = fwrite($remote, $encryptedData);
printf(&quot;Forward %d bytes data to remote.\n&quot;, $send);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 PHP 5.0 之后的版本中我们可以直接使用 &lt;code&gt;stream_socket_client&lt;/code&gt; 来创建 socket 连接，然后将加密好的数据发送到 ss-server。ss-server 会解密数据再将其转发到目标服务器。我们只需等待 ss-server 的回应即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$encryptedResponse = &quot;&quot;;
stream_set_timeout($remote, 1);
while(true) {
    // 在阻塞模式中不能使用 stream_socket_recvfrom，stream_set_timeout 的设置对其无效
    // chunk size 一般为 8192
    $buffer = fread($remote, 8192);
    if (&quot;&quot; === $buffer || false === $buffer) {
        break;
    }
    $encryptedResponse .= $buffer;
}
$response = $encryptor-&amp;gt;decrypt($encryptedResponse);
printf(
    &quot;Receive %d bytes data from remote.\nResponse content:\n\n %s\n&quot;, 
    strlen($response), 
    $response
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;考虑到数据被分片的情况，我们使用无限循环保证读取到所有数据，再使用 Encryptor 解密数据，你应该可以看回应的内容大致为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Forward 91 bytes data to remote.
Receive 526 bytes data from remote.
Response content:

HTTP/1.1 302 Found
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Location: http://www.google.co.jp/?gfe_rd=cr&amp;amp;ei=f27dVNmCGY2nmQW83YBo
Content-Length: 259
Date: Fri, 13 Feb 2015 03:24:47 GMT
Server: GFE/2.0
Alternate-Protocol: 80:quic,p=0.08

&amp;lt;HTML&amp;gt;&amp;lt;HEAD&amp;gt;&amp;lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot;&amp;gt;
&amp;lt;TITLE&amp;gt;302 Moved&amp;lt;/TITLE&amp;gt;&amp;lt;/HEAD&amp;gt;&amp;lt;BODY&amp;gt;
&amp;lt;H1&amp;gt;302 Moved&amp;lt;/H1&amp;gt;
The document has moved
&amp;lt;A HREF=&quot;http://www.google.co.jp/?gfe_rd=cr&amp;amp;amp;ei=f27dVNmCGY2nmQW83YBo&quot;&amp;gt;here&amp;lt;/A&amp;gt;.
&amp;lt;/BODY&amp;gt;&amp;lt;/HTML&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这表明我们已经成功将请求发送到了 Google 的服务器。由于我的 ss-server 服务器在日本，所以 Google 回应了一个 302 跳转。在请求完成之后就可以关闭通道了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;stream_socket_shutdown($remote, STREAM_SHUT_RDWR);
fclose($remote);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此我们已经完成了一个非常简陋的客户端，它只能纯手工构建请求，并且在完成一次通信之后就退出了，但是这并不重要，重要的是我们了解了它的原理。如果你想要完善这个客户端，可以自己为它补上 SOCKS server 的功能，也可以使用其他开源实现，比如：&lt;a href=&quot;https://github.com/clue/php-socks-react&quot;&gt;&lt;a href=&quot;https://github.com/clue/php-socks-react&quot;&gt;https://github.com/clue/php-socks-react&lt;/a&gt;&lt;/a&gt;。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Simple Qiniu SDK 使用说明]]></title>
		<link href="http://blog.shouhuiben.net/article/2015/01/26/how-to-use-simple-qiniu-sdk" />
		<id>urn:uuid:bfa3f512-e9ed-cb3b-1319-8e8d50740b98</id>
		<updated>2015-01-26T11:06:51+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;为了解决&lt;a href=&quot;http://www.shouhuiben.com&quot;&gt;「手绘本」&lt;/a&gt;的头像托管问题，前几天重写了一遍 &lt;a href=&quot;https://github.com/zither/simple-qiniu-sdk&quot;&gt;Simple Qiniu SDK&lt;/a&gt;，剔除了上传以外的其他功能。这是吸取了之前的教训：只维护自己用得到的代码。因此现在的 Simple Qiniu SDK 只能用于小文件上传。下面是一个简单的使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;// Autoload 源码：https://github.com/zither/simple-qiniu-sdk/blob/master/example/Autoload.php
require __DIR__ . &quot;/Autoload.php&quot;;
Autoload::addNamespace(&#039;Qiniu&#039;, dirname(__DIR__) . &#039;/src/Qiniu&#039;);
Autoload::register();

$accessKey = &#039;accessKey&#039;;
$secretKey = &#039;secretKey&#039;;
$qiniu = new \Qiniu\Qiniu($accessKey, $secretKey);

$bucket = $qiniu-&amp;gt;getBucket(&#039;sketch&#039;);
$response = $bucket-&amp;gt;put($_FILES[&#039;file&#039;][&#039;tmp_name&#039;]);
echo $response-&amp;gt;getContent();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次重写我剔除了 Simple Qiniu SDK 中的自动加载函数，所以在使用前你需要自己解决自动加载问题（推荐使用 Composer）。这个示例使用的是默认设置，如果你需要修改七牛的上传策略，可以使用 setPolicy 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$bucket = $qiuniu-&amp;gt;getBucket(&#039;sketch&#039;);
// 更多策略参数请参考：http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html
$bucket-&amp;gt;setPolicy(array(
    &#039;saveKey&#039; =&amp;gt; sprintf(&quot;%s.jpg&quot;, time()),
    &#039;returnBody&#039; =&amp;gt; &#039;{&quot;key&quot;: $(key),&quot;name&quot;: $(fname)}&#039;,
    &#039;expires&#039; =&amp;gt; 3600
));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你不仅可以指定文件保存的名称，还可以设置 \Qiniu\Bucket::EXTR_OVERWRITE 参数来启用 put（更新） 模式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$bucket-&amp;gt;put($_FILES[&#039;file&#039;][&#039;tmp_name&#039;], &#039;avatar.png&#039;, \Qiniu\Bucket::EXTR_OVERWRITE);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以自定义一些魔术变量，然后以数组的形式传递给 put 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$bucket-&amp;gt;setPolicy(array(
    // 通过 returnBody 的形式返回魔术变量
    &#039;returnBody&#039; =&amp;gt; &#039;{&quot;key&quot;: $(key), &quot;user&quot;: $(x:user)}&#039;,                  
));
$uploadParams = array(
    // 文件保存名称
    &#039;key&#039; =&amp;gt; &#039;avatar.png&#039;,
    // 自定义魔术变量
    &#039;x:user&#039; =&amp;gt; &#039;Simple Qiniu SDK&#039;
);
$bucket-&amp;gt;put($_FILES[&#039;file&#039;][&#039;tmp_name&#039;], $uploadParams);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你希望采用&lt;a href=&quot;http://developer.qiniu.com/docs/v6/api/overview/up/form-upload.html&quot;&gt;表单上传模式&lt;/a&gt;，你可以使用 getUpToken 方法来获取上传令牌：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;form action=&quot;http://upload.qiniu.com/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
    &amp;lt;input name=&quot;file&quot; type=&quot;file&quot; /&amp;gt;
    &amp;lt;input name=&quot;x:user&quot; type=&quot;hidden&quot; value=&quot;Simple Qiniu SDK&quot;&amp;gt;
    &amp;lt;input name=&quot;token&quot; type=&quot;hidden&quot; value=&quot;&amp;lt;?=$bucket-&amp;gt;getUpToken()?&amp;gt;&quot;&amp;gt;
    &amp;lt;button id=&quot;upload&quot; type=&quot;submit&quot;&amp;gt;上传到七牛&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上就是重构后 Simple Qiniu SDK 所有功能的使用说明，如果你还需要「删除文件」等其他功能，可以自行修改或者使用&lt;a href=&quot;http://developer.qiniu.com/docs/v6/sdk/php-sdk.html&quot;&gt;官方 SDK&lt;/a&gt;。当然，如果我也有了对应的使用需求，也会给 Simple Qiniu SDK 增加对应的功能支持。 &lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Y combinator in PHP]]></title>
		<link href="http://blog.shouhuiben.net/article/2015/01/14/Y-combinator-in-php" />
		<id>urn:uuid:7a82866a-30ca-4389-11a8-056a44733566</id>
		<updated>2015-01-14T13:45:40+08:00</updated>
		<summary type="html"><![CDATA[&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$Y = function($f){
    $x = function($s) use($f){
        return function($n) use($s, $f){
            return $f($s($s))-&amp;gt;__invoke($n);
        };
    };
    return $x($x);
};

$factorial = $Y(function($recurse){
    return function($x) use($recurse){
        return $x === 0 ? 1 : $x * $recurse($x - 1);  
    };         
});

echo $factorial(6); // 720&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;花了一些时间用 PHP 推导了一遍 Y combinator，因为语法上的一些原因，推导过程中总觉得怪怪的。推导结果代码如上所示，精简和美观程度与 LISP 相差甚远，也就勉强能看。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[手动更新 VirtualBox Guest Additions]]></title>
		<link href="http://blog.shouhuiben.net/article/2014/11/02/update-virtualbox-guest-additions" />
		<id>urn:uuid:8006baa1-d4d8-a0c1-9595-8c3fe7df9f18</id>
		<updated>2014-11-02T10:59:22+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;在使用 Vagrant 作为开发环境一段时间后，发现 Vagrant 也并不能做到完全的无缝迁移。昨天更新系统软件之后，在运行 Vagrant 时提示了 VirtualBox Guest Additions 版本不匹配的警告。这个问题一般是由 VirtualBox 更新引起的，在我们的 Vagrant 环境中，Guest Additions 版本不同最可能出现的问题就是无法挂载共享文件夹。&lt;/p&gt;
&lt;p&gt;上面的问题可以通过升级 Vagrant box 里的 Guest Additions 来解决，升级也可以采用自动和手动两种方式。&lt;/p&gt;
&lt;p&gt;Vagrant 的 Vbguest plugin 可以在启动时自动检测 Guest Additions 的版本，如果版本不同则自动更新同步，具体教程可以参考这篇教程：&lt;a href=&quot;http://kvz.io/blog/2013/01/16/vagrant-tip-keep-virtualbox-guest-additions-in-sync/&quot;&gt;Vagrant Tip: Sync VirtualBox Guest Additions&lt;/a&gt;。我测试了一下这个插件，整个更新过程基本上是不需要人为操作，但是由于国内的网络问题，可能在下载新版本 Guest Additions(60MB+) 时需要等待比较长的时间。&lt;/p&gt;
&lt;p&gt;不过我最后还是采用了手动更新，因为使用 Vagrant 的目的是尽量不折腾，就没必要在解决由于依赖引起的问题时引入新的依赖隐患。Guest Additions 的介绍和手动更新方法在 VirtualBox 的文档 &lt;a href=&quot;https://www.virtualbox.org/manual/ch04.html&quot;&gt;Chapter 4. Guest Additions&lt;/a&gt; 中写得非常详细了。在这里只是把步骤做一个简单的记录，方便以后需要时查看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# 在 Vagrant box 中安装更新依赖
vagrant@precise32:~$ sudo apt-get install linux-headers-$(uname -r) build-essential dkms
# 下载新版本的 Guest Additions
vagrant@precise32:~$ wget http://download.virtualbox.org/virtualbox/4.3.10/VBoxGuestAdditions_4.3.10.iso
# 挂载镜像
vagrant@precise32:~$ sudo mount VBoxGuestAdditions_4.3.10.iso -o loop,ro /mnt
# 卸载旧版本，可省略
vagrant@precise32:~$ sudo sh /mnt/VBoxLinuxAdditions.run uninstall
# 安装新版本
vagrant@precise32:~$ sudo sh /mnt/VBoxLinuxAdditions.run&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手动安装的过程也非常简单，但是不论是手动还是自动安装完成之后，启动时都可能会遇到以下这两个问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;Failed to mount folders in Linux guest. This is usually because
the &quot;vboxsf&quot; file system is not available. Please verify that
the guest additions are properly installed in the guest and
can work properly. The command attempted was:

mount -t vboxsf -o uid=`id -u vagrant`,gid=`getent group vagrant | cut -d: -f3` /vagrant /vagrant
mount -t vboxsf -o uid=`id -u vagrant`,gid=`id -g vagrant` /vagrant /vagrant&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个问题普遍反映在 Guest Additions 4.3.10 版本中，可以通过这个命令解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vagrant@precise32:~$ sudo ln -sv /opt/VBoxGuestAdditions-4.3.10/lib/VBoxGuestAdditions \
/usr/lib/VBoxGuestAdditions&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外一个问题则表现为在新版安装成功之后依然会提示版本不匹配，VirtualBox 检测到的仍然是已经卸载掉的旧版本。首先需要确认新版本已经安装成功，检测是否已经安装了 vboxguest ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;vagrant@precise32:~$ lsmod | grep -i vbox
vboxsf                 42523  1 
vboxguest             219244  2 vboxsf
vboxvideo              12550  0 
drm                   197692  1 vboxvideo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看 vboxguest 版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vagrant@precise32:~$ modinfo vboxguest
filename:       /lib/modules/3.2.0-23-generic-pae/updates/dkms/vboxguest.ko
version:        4.3.10
license:        GPL
description:    Oracle VM VirtualBox Guest Additions for Linux Module
author:         Oracle Corporation
srcversion:     FDAC0A8218FE4AEFD8732E8
alias:          pci:v000080EEd0000CAFEsv00000000sd00000000bc*sc*i*
depends:        
vermagic:       3.2.0-23-generic-pae SMP mod_unload modversions 686 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看 guestproperty 中的版本号（id 可以在项目目录的 .vagrant/machines/default/virtualbox/id 中查看）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;MiniThinker@localhost:~$ VBoxManage guestproperty get &amp;lt;id&amp;gt; /VirtualBox/GuestAdd/Version
Value: 4.2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面确认已经成功安装新版本，VBoxManage 仍然检测到的是旧版本，手动设置更新版本号：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;MiniThinker@localhost:~$ VBoxManage guestproperty set &amp;lt;id&amp;gt; /VirtualBox/GuestAdd/Version&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在问题解决后重新打包整个环境即可，如果不怕麻烦的话，可以卸载和删掉更新过程中安装和下载的文件。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Youdao firefox alpha]]></title>
		<link href="http://blog.shouhuiben.net/article/2014/10/13/youdao-firefox-alpha" />
		<id>urn:uuid:4698458b-c3cd-d4cb-2845-a8c0003e4074</id>
		<updated>2014-10-13T15:25:17+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;Chromium 升级到版本 37 后在 linux 下的变现欠佳。特别是在字体方面，就算在 Chromium 中设置了相关的字体，也不能完全得到改善。不过 Firefox 32 的表现却与之相反，启动速度、浏览器界面与字体渲染都令人非常满意，所以在 Chromium 相关问题未得到解决的情况下，我会将 Firefox 作为默认浏览器。之前在 Chromium 中使用的大部分插件也有对应的 Firefox 版本，没有迁移障碍。不过翻译插件的迁移就没有那么顺利了。&lt;/p&gt;
&lt;p&gt;之前在 Chromium 中主要使用有道词典的划词插件以及网友开发的 Halo 词典，这两者都没有对应的 Firefox 版本。Firefox 自身的翻译插件基本上都是基于 Google 翻译，以目前的网络环境来看，没翻墙的情况下差不多都已残废。我在 Firefox 插件列表中找到了一个叫 Youdao-firefox 的翻译插件，界面和快捷键还比较适合，但是试用的时候发现无法会出现无法翻译的问题，把插件解包了大致看了一下源代码，它依然使用的是 Google 翻译的接口，这是几个意思啊？&lt;/p&gt;
&lt;p&gt;既然没能找到好用的翻译插件，那就只能自己动手了，&lt;a href=&quot;https://github.com/zither/youdao-firefox&quot;&gt;Youdao-firefox-alpha&lt;/a&gt; 就这样诞生了。我在 Youdao-firefox 的基础上，将 Google 翻译接口调整为有道词典的接口，删掉了仅对 Google 有用的多语言翻译配置，以及除中英以外的其他国际化支持。在界面和快捷键上仍然与原版一致，在选中单词过后按下 alt + z 就会弹出翻译框。暂时我只添加了有道翻译的基本释意，所以在翻译结果中不能看到网络释意，以后是否会支持还未决定。&lt;/p&gt;
&lt;p&gt;插件包不准备放到官方网站上去，所以如果你也需要的话可以在 &lt;a href=&quot;https://github.com/zither/youdao-firefox/releases&quot;&gt;Github&lt;/a&gt; 上下载已经打包好的插件。当然，你也可以 fork 之后增加自己需要的功能，然后重新打包。&lt;/p&gt;]]></summary>
	</entry>
</feed>