<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title><![CDATA[MiniThinker]]></title>
	<subtitle>努力学习那些想要知道的东西</subtitle>
	<link href="http://blog.minimee.org/atom.xml" rel="self" />
	<link href="http://blog.minimee.org/" />
	<id>urn:uuid:6b18cbf9-83ff-86cd-1c01-f6fa3c1a351c</id>
	<updated>2014-03-23T19:30:22+08:00</updated>
	<author>
		<name><![CDATA[Minimee]]></name>
		<uri>http://blog.minimee.org/</uri>
	</author>
	<entry>
		<title type="html"><![CDATA[谁动了我的 php.vim]]></title>
		<link href="http://blog.minimee.org/article/2014/03/23/who-changed-my-php-vim" />
		<id>urn:uuid:b8e64e6b-7392-1cd8-4df6-3e7d2abb1fda</id>
		<updated>2014-03-23T17:59:17+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;最近发生了一个非常诡异的事情，我的 vim 语法高亮竟然自动变了！在&lt;a href=&quot;http://blog.minimee.org/article/2014/03/20/the-problem-of-vim-css-color&quot;&gt;前一篇博客&lt;/a&gt;中我提到过：从我使用 vim 编辑器以来，color scheme 一直都是 &lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=2536&quot;&gt;lucius&lt;/a&gt;。它之前的模样可以在&lt;a href=&quot;http://minimee.org/vim/&quot;&gt;这篇介绍&lt;/a&gt;中看到。&lt;/p&gt;
&lt;p&gt;从图片中可以看到 php 注释要比 php 普通代码的颜色要暗很多，不会吸引到视觉焦点，这也是我选择 color scheme 最重要的标准之一。但是最近它竟然自己把颜色给换了，难道注释也变得不甘寂寞了么？&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;http://ww1.sinaimg.cn/large/86e701f8gw1eepv20rot2j21ao07xdgn.jpg&quot;&gt;这张图片&lt;/a&gt;可以看到，注释中部分文字改变了高亮颜色！奇怪的是最近我并没有任何更新 vim 的操作，我也不知道为什么变成了这样。在更换了多个 color scheme 之后发现，这个问题影响到了所有的 color scheme，也就是说问题与 color scheme 自身没有关系。而是 vim highlight groups 中混入了奇怪的东西。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vimL&quot;&gt;hi Comment          guifg=#808080           gui=none
hi Comment          ctermfg=243             cterm=none&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几行代码是 lucius 配色中关于注释的颜色设置，现在我需要找到混在 Comment group 中的其他 group。这时可以祭出 &lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=383&quot;&gt;SyntaxAttr.vim&lt;/a&gt; 这件大杀器，它的功能很简单，就是可以获取鼠标所在文字的 highlight group 信息。插件安装成功之后可以使用以下命令来获取 highlight group 信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vimL&quot;&gt;:call SyntaxAttr()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用这个插件我找到了注释中高亮部分的 highlight group：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vimL&quot;&gt;group: phpDocTags-&amp;gt;PreProc guifg=#efefaf(#efefaf)
group: phpDocCustomTags-&amp;gt;Type guifg=#93e690(#93e690)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很显然，在 lucius scheme 之中并没有定义与这两个 group 相关的设置，关于这两个 group 的定义可以在 vim 的 syntax/php.vim 中找到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;syntax match  phpDocCustomTags  &quot;@[a-zA-Z]*\(\s\+\|\n\|\r\)&quot; containedin=phpComment
syntax region phpDocTags  start=&quot;{@\(example...\|tutorial\)&quot; end=&quot;}&quot; containedin=phpComment
syntax match  phpDocTags  &quot;@\(abstract\....\|throws\)\(\s\+\)\?&quot; containedin=phpComment&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后为了让这两个不安分的 highlight group 低调一点，我直接在 lucius scheme 中添加了如下两行设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hi phpDocTags       guifg=#808080                                   gui=none
hi phpDocCustomTags guifg=#808080                                   gui=none&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后整个 vim 又恢复到之前的宁静了。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[vim-css-color 严重降低 vim 启动速度]]></title>
		<link href="http://blog.minimee.org/article/2014/03/20/the-problem-of-vim-css-color" />
		<id>urn:uuid:9e38c325-21d4-dbe7-2b06-db724cc6295a</id>
		<updated>2014-03-20T12:11:09+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;因为一直使用 vim-gtk 的缘故，我其实很少使用 vim 进行编程，color scheme 更是一直使用 &lt;a href=&quot;http://www.vim.org/scripts/script.php?script_id=2536&quot;&gt;lucius&lt;/a&gt;。不过最近有些工作必须要在终端下完成，为了改善在 vim 中编程的体验，我还是决定升级下终端版本，并专门把 vim 的配色更换为 &lt;a href=&quot;https://github.com/chriskempson/tomorrow-theme&quot;&gt;Tomorrow-Night&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我使用的终端是 rxvt-unicode，默认为88色，而 Tomorrow-Night 的 256 色要比 88 色看起来舒服很多，所以我直接把 rxvt-unicode 换成了 rxvt-unicode-256color。没想到在终端更换完毕之后出现了一个问题：用 vim 打开文件的速度变得非常慢，最少需要4-5秒左右。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;使用如下命令来查看 vim 的启动过程耗费的时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;vim --startuptime timefile test.php&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令会打开 test.php 文件并在当前目录生成一个名为 timefile 的启动日志文件。然后我在日志文件中找到了拖慢 vim 启动速度的真凶：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;191.477  004.767  004.767: sourcing /usr/share/vim/vim74/syntax/vb.vim
4279.165  4087.443  4087.443: sourcing /home/chou/.vim/bundle/css_color.vim/syntax/css.vim&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从日志中可以看到，大部分时间都被用于加载这个名为 css_color.vim 的插件。话说这个插件比较好玩，特别是对于经常接触前端的朋友，它可以自动修改文件中表示各种颜色格式文字（比如 #ffffff）的背景，然后让人可以直观的看到这些数字组成的颜色。我当即在 .vimrc 配置中去掉了这个插件，然后 vim 的启动速度恢复正常。&lt;/p&gt;
&lt;p&gt;随手 google 了一下，发现非常多的人在 &lt;a href=&quot;https://github.com/skammer/vim-css-color/issues/3&quot;&gt;github issue&lt;/a&gt; 上提出了这个问题，但是作者未作任何回复。大致是由于插件的 rgb2xterm 函数效率过低。不过有好心的网友自己对这个问题进行了更新修复，更新后的插件可以在这里找到：&lt;a href=&quot;https://github.com/ap/vim-css-color&quot;&gt;&lt;a href=&quot;https://github.com/ap/vim-css-color&quot;&gt;https://github.com/ap/vim-css-color&lt;/a&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;之前在 88 色终端下并未发现这个问题是由于插件在开头添加了这样一行环境检测代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-vimL&quot;&gt;if !( has(&#039;gui_running&#039;) || &amp;amp;t_Co==256 ) | finish | endif&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;PS：我顺手安装测试了一下网友修正过的插件，启动速度很快，推荐使用。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Feed 解析那些库]]></title>
		<link href="http://blog.minimee.org/article/2014/03/13/feedparser" />
		<id>urn:uuid:c6ee9e6a-221b-760e-a87f-ae3e66e03fdd</id>
		<updated>2014-03-13T10:26:53+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;前几天做了一个比较小的项目，大部分功能都涉及到 feed 解析。关于 feed 解析我之前也写过相关的代码，因为所需 feed 的情况都在自己的控制之内，当时使用的是自己写的一个解析类。这次项目要求要更加通用一些，所以在进行过程搜索了各种开源的 feed 解析库。&lt;/p&gt;
&lt;p&gt;最先关注到的解析库是 SimplePie，它的功能比较齐全，基本上支持全格式的 feed 解析，还包括了转码缓存等功能。不过在解析中文订阅的时候会出现将中文编码为 HTML Entities 的问题。随手 google 了一下，发现有人已经遇到过相同的问题：&lt;a href=&quot;http://blog.webfuns.net/archives/1710.html&quot;&gt;SimplePie 将中文编码成 HTML Entities 的解决办法&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;文中已经说明出现这个问题的原因，并且给出了一个解决办法，不过修改方法不太清楚，这里详细说一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;// 修改的内容在 SimplePie_Sanitize 类的 sanitize 方法中
class SimplePie_Sanitieze
{
    // 忽略无关的内容
    // ...
    // ...

    public function sanitize($data, $type, $base = &#039;&#039;)
    {
        // 忽略无关内容
        // ...
        // ...

        if ($type &amp;amp; (SIMPLEPIE_CONSTRUCT_HTML | SIMPLEPIE_CONSTRUCT_XHTML))
        {
            $document = new DOMDocument();
            $document-&amp;gt;encoding = &#039;UTF-8&#039;;

            // 增加一下两行代码
            $unique_tag = &#039;#&#039; . uniqid() . &#039;#&#039;;
            $data = $unique_tag . $data . $unique_tag;

            $data = $this-&amp;gt;preprocess($data, $type);
            // 继续忽略无关内容
            // ...
            // ...

            // 直接注释下面这两行代码
            //$real_body = $document-&amp;gt;getElementsByTagName(&#039;body&#039;)-&amp;gt;item(0)-&amp;gt;childNodes-&amp;gt;item(0);
            //$document-&amp;gt;replaceChild($real_body, $document-&amp;gt;firstChild);

            $data = trim($document-&amp;gt;saveHTML());

            // 最后在添加下面这行代码
            list($_, $data, $_) = explode($unique_tag, $data);

            // ...
            // ...
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了 SimplePie 之外还在 Github 上找到一个非常小的解析库：&lt;a href=&quot;https://github.com/dzeban/FeedParser&quot;&gt;FeedParser&lt;/a&gt;。这个库的功能相比 SimplePie 要简陋太多，不过好在它足够简单，源代码看完想怎么改就怎么改。FeedParser 的作者也是因为自己需要而写的，最后更新在 3 年之前，提供的接口是使用 XPath 硬查询的，所以如果有特殊的需求需要自己修改代码。我自己使用的时候也添加过一些简单的接口，代码放在：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// FeedParser Github repo
https://github.com/dzeban/FeedParser
// 我小小修改过的
https://github.com/zither/FeedParser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;总的来说，FeedParser 适合自己玩，正规一些的项目可以考虑使用 SimplePie。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[Slim 中关于 Closure 的问题]]></title>
		<link href="http://blog.minimee.org/article/2014/02/19/confusion-about-closure-in-slim" />
		<id>urn:uuid:d0fd92ab-df21-349c-6ab3-180ef2418578</id>
		<updated>2014-02-19T15:46:17+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;在翻译 Slim 框架文档的依赖注入（Dependency Injection）部分时发现一个可能会让人迷惑的地方。Slim 框架的所有变量都储存在 \Slim\Helper\Set 类的实例中，我们可以像平常一样向 Slim 中注入需要的变量。但是在注入 Closure 或 lambda 时就会和想象中不太一样。这里直接使用用官方文档中的例子来说明：&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;$app = new \Slim\Slim();
$app-&amp;gt;uuid = function(){
    return exec(&#039;uuidgen&#039;);
};
// 获取一个新的 UUID
$uuid = $app-&amp;gt;uuid;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中，我们把一个 lambda 函数赋值给了名为 uuid 的变量，通常我们需要手动调用这个 lambda 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;// 实例变量不能通过 $app-&amp;gt;uuid(); 方法调用
$uuid = $app-&amp;gt;uuid;
$uuid();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在 Slim 中不需要手动调用，它在 \Slim\Helper\Set 类中使用了自动调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;public function get($key, $default = null)
{
    if ($this-&amp;gt;has($key)) {
        // 检测变量是否可以调用
        $isInvokable = is_object($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]) &amp;amp;&amp;amp; 
            method_exists($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)], &#039;__invoke&#039;);

        return $isInvokable ? 
            // 直接调用
            $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]($this) : 
            $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)];
    }
    return $default;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们需要存储原始的闭包（Closure），则必须使用 \Slim\Helper\Set 的 protect 的方法。这虽然节省了一些操作代码，但是在不了解 Slim 的情况下会带来一些麻烦。&lt;/p&gt;]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[编程语言从哪里来]]></title>
		<link href="http://blog.minimee.org/article/2014/02/17/what-is-a-programming-language" />
		<id>urn:uuid:41897e6d-83f8-9cca-142e-2d3bce5ffd62</id>
		<updated>2014-02-17T15:59:12+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;我学习的第一门编程语言是 ASP，想做一个个人网站，后来陆续接触到 PHP、C、Python、Scheme 等语言。因为一直都是自学，所以在学习过程中心里总是有很多疑惑。其中最大的疑惑就是现在这么多编程语言到底是从哪里来的？也许有些可笑，编程语言当然都是人写的。各种语言书籍中都会提到语言的发展，比如学习 PHP 时他们会告诉你 PHP 是用 C 语言写的。最初的 C 语言又是由 B 语言开发的。这些发展过程好像有迹可循，所以我忽略了一些重要的东西。&lt;/p&gt;
&lt;p&gt;&amp;lt;!--more--&gt;&lt;/p&gt;
&lt;p&gt;但是在接触到 LISP 和 Scheme 的时候上面的疑惑又出现了。Scheme 的语法很简单，所以大部分教程也相对简洁，很多时候都是让你用 Scheme 进行各种数字计算，或者是让你在屏幕上输出一句“Hello, world!”。然后他们会告诉你你现在已经可以用 Scheme 做任何想做的事情了。然后就没有然后了。&lt;/p&gt;
&lt;p&gt;每次看到这样的教程都有掀桌的冲动有木有。不过从语言的发展上我们至少可以得到这样一个结论：一种语言最初都是由另一种语言编写的。所以它所有的能力最初都来自于编写它的语言，这样我们可以一直追溯到最早的程序语言：机器语言和汇编语言。&lt;/p&gt;
&lt;p&gt;在这两者之间我们可以看到程序语言的分界线，即计算机最初只能识别机器语言而不能识别汇编语言。机器语言是用二进制代码表示的处理器指令集，最初的指令就是各种控制面板的开关而已。也就是说机器语言的能力来自于处理器，是最低级的语言。&lt;/p&gt;
&lt;p&gt;汇编语言是由与指令集命令一一对应的助记符组成的。这是由于机器语言只包括“开”和“关”，或者说只包括“1”和“0”。你可以把它打孔到纸条或纸卡上，但它实在是太难记了，所以人们想到用各种英文单词来代替一长串数字指令。但这时计算机仍然不能识别它，在纸上编写的汇编代码仍然需要人工把助记符翻译成机器语言命令。&lt;/p&gt;
&lt;p&gt;直到第一个汇编器的出现，我们可以把它简单的理解为用机器语言编写的汇编代码翻译程序。汇编器可以通过查表的方式把汇编代码一一翻译为机器码。这就意味着我们可以用汇编代码来输入指令，甚至是用汇编语言来编写汇编器了。对于想知道怎么用“0”和“1”来表示代码字母的朋友可以搜索了解下二进制和字符编码相关内容。&lt;/p&gt;
&lt;p&gt;现在我们可以稍微明白一些专业术语将的是些什么内容了。比如之前听起来非常高大上的“反编译”或者“逆向工程”，其实就是把二进制机器码用反汇编器转换为汇编代码，然后理解计算逻辑，并试图用高级语言还原出来的过程。比如我们应该明白各种编程语言在功能上的差别到底在哪里，这是其实由实现他们的编译器或者解释器来决定的。所以当我们想问 Scheme 能做什么的时候，应该去看看 Scheme 的解释器或编译器提供了哪些功能。&lt;/p&gt;]]></summary>
	</entry>
</feed>