<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title><![CDATA[MiniThinker]]></title>
	<subtitle>努力学习那些想要知道的东西。</subtitle>
	<link href="http://blog.minimee.org/atom.xml" rel="self" />
	<link href="http://blog.minimee.org/" />
	<id>urn:uuid:6b18cbf9-83ff-86cd-1c01-f6fa3c1a351c</id>
	<updated>2014-02-19T16:51:18+08:00</updated>
	<entry>
		<title type="html"><![CDATA[Slim 中关于 Closure 的问题]]></title>
		<link href="http://blog.minimee.org/article/2014/02/19/confusion-about-closure-in-slim" />
		<id>urn:uuid:d0fd92ab-df21-349c-6ab3-180ef2418578</id>
		<updated>2014-02-19T15:46:17+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;在翻译 Slim 框架文档的依赖注入（Dependency Injection）部分时发现一个可能会让人迷惑的地方。Slim 框架的所有变量都储存在 &lt;strong&gt;\Slim\Helper\Set&lt;/strong&gt; 类的实例中，我们可以像平常一样向 Slim 中注入需要的变量。但是在注入 Closure 变量时就会和想象中不太一样。这里直接使用用官方文档中的例子来说明：&lt;/p&gt;

&lt;!--more--&gt;

&lt;pre&gt;&lt;code&gt;$app = new \Slim\Slim();
$app-&amp;gt;uuid = function(){
    return exec(&#039;uuidgen&#039;);
};
// 获取一个新的 UUID
$uuid = $app-&amp;gt;uuid;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在这个例子中，我们把一个匿名函数赋值给了名为 uuid 的变量，通常我们需要手动调用这个匿名函数：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 实例变量不能通过 $app-&amp;gt;uuid(); 方法调用
$uuid = $app-&amp;gt;uuid;
$uuid();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是在 Slim 中不需要手动调用，它在 \Slim\Helper\Set 类中使用了自动调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public function get($key, $default = null)
{
    if ($this-&amp;gt;has($key)) {
        // 检测变量是否可以调用
        $isInvokable = is_object($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]) &amp;amp;&amp;amp; 
            method_exists($this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)], &#039;__invoke&#039;);

        return $isInvokable ? 
            // 直接调用
            $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)]($this) : 
            $this-&amp;gt;data[$this-&amp;gt;normalizeKey($key)];
    }
    return $default;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果我们需要存储原始的匿名函数，则必须使用 \Slim\Helper\Set 的 protect 的方法。这虽然节省了一些操作代码，但是在不了解 Slim 的情况下会带来一些麻烦。&lt;/p&gt;
]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[编程语言从哪里来]]></title>
		<link href="http://blog.minimee.org/article/2014/02/17/what-is-a-programming-language" />
		<id>urn:uuid:41897e6d-83f8-9cca-142e-2d3bce5ffd62</id>
		<updated>2014-02-17T15:59:12+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;我学习的第一门编程语言是 ASP，想做一个个人网站，后来陆续接触到 PHP、C、Python、Scheme 等语言。因为一直都是自学，所以在学习过程中心里总是有很多疑惑。其中最大的疑惑就是现在这么多编程语言到底是从哪里来的？也许有些可笑，编程语言当然都是人写的。各种语言书籍中都会提到语言的发展，比如学习 PHP 时他们会告诉你 PHP 是用 C 语言写的。最初的 C 语言又是由 B 语言开发的。这些发展过程好像有迹可循，所以我忽略了一些重要的东西。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;但是在接触到 LISP 和 Scheme 的时候上面的疑惑又出现了。Scheme 的语法很简单，所以大部分教程也相对简洁，很多时候都是让你用 Scheme 进行各种数字计算，或者是让你在屏幕上输出一句“Hello, world!”。然后他们会告诉你你现在已经可以用 Scheme 做任何想做的事情了。然后就没有然后了。&lt;/p&gt;

&lt;p&gt;每次看到这样的教程都有掀桌的冲动有木有。不过从语言的发展上我们至少可以得到这样一个结论：一种语言最初都是由另一种语言编写的。所以它所有的能力最初都来自于编写它的语言，这样我们可以一直追溯到最早的程序语言：机器语言和汇编语言。&lt;/p&gt;

&lt;p&gt;在这两者之间我们可以看到程序语言的分界线，即计算机最初只能识别机器语言而不能识别汇编语言。机器语言是用二进制代码表示的处理器指令集，最初的指令就是各种控制面板的开关而已。也就是说机器语言的能力来自于处理器，是最低级的语言。&lt;/p&gt;

&lt;p&gt;汇编语言是由与指令集命令一一对应的助记符组成的。这是由于机器语言只包括“开”和“关”，或者说只包括“1”和“0”。你可以把它打孔到纸条或纸卡上，但它实在是太难记了，所以人们想到用各种英文单词来代替一长串数字指令。但这时计算机仍然不能识别它，在纸上编写的汇编代码仍然需要人工把助记符翻译成机器语言命令。&lt;/p&gt;

&lt;p&gt;直到第一个汇编器的出现，我们可以把它简单的理解为用机器语言编写的汇编代码翻译程序。汇编器可以通过查表的方式把汇编代码一一翻译为机器码。这就意味着我们可以用汇编代码来输入指令，甚至是用汇编语言来编写汇编器了。对于想知道怎么用“0”和“1”来表示代码字母的朋友可以搜索了解下二进制和字符编码相关内容。&lt;/p&gt;

&lt;p&gt;现在我们可以稍微明白一些专业术语将的是些什么内容了。比如之前听起来非常高大上的“反编译”或者“逆向工程”，其实就是把二进制机器码用反汇编器转换为汇编代码，然后理解计算逻辑，并试图用高级语言还原出来的过程。比如我们应该明白各种编程语言在功能上的差别到底在哪里，这是其实由实现他们的编译器或者解释器来决定的。所以当我们想问 Scheme 能做什么的时候，应该去看看 Scheme 的解释器或编译器提供了哪些功能。&lt;/p&gt;
]]></summary>
	</entry>
	<entry>
		<title type="html"><![CDATA[重新整理博客]]></title>
		<link href="http://blog.minimee.org/article/2014/02/16/rebuild-blog" />
		<id>urn:uuid:cf45027f-6ba6-5cee-c036-471afd8fcf5f</id>
		<updated>2014-02-16T15:10:04+08:00</updated>
		<summary type="html"><![CDATA[&lt;p&gt;距离上次写博客已经是很久以前的事情了，因为放弃使用 Laravel 框架之后也就再也没有使用自己为 Laravel 框架写的静态博客插件。最近有一些学习上的东西想要记录一下，所以又切换到之前介绍过的 Pointless 静态博客程序。不过值得庆幸的是 Pointless 直到现在都还在更新维护，所以提交了一个半角双引号可能引起问题的 Issue。&lt;/p&gt;

&lt;p&gt;目前版本的 Pointless 和我一年多前用过的有蛮大的差别。大致浏览了一下程序目录，发现在自定义模板这部分有些不太直观，我直接去掉了 side 部分，然后把 comment 链接移到了 Tag 之后。暂时先这样用着，以后重新修改一个更简单点的模板。&lt;/p&gt;

&lt;!--more--&gt;

&lt;p&gt;稍微调整了下博客的主题，因为一贯喜欢简洁的页面，所以直接在官方 Classic 主题上做了减法，去掉了所有用不掉的元素。但是现在还没对引用和代码块做样式上的修改。另外有点想调整下 markdown 语法，改为更加接近 Github Flavored Markdown 的语法。搜索了一下，发现一个名叫 &lt;a href=&quot;http://parsedown.org&quot;&gt;parsedown&lt;/a&gt; 的解析库。&lt;/p&gt;
]]></summary>
	</entry>
</feed>