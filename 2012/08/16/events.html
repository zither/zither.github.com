
<!doctype html>
<html lang="zh-CN">
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <title>Laravel Events | 槐花九九</title>
  <meta name="author" content="MiniMee" />
  <link href="/atom.xml" rel="alternate" title="Tom Preston-Werner" type="application/atom+xml" />
  <link rel="stylesheet" href="/css/screen.css" type="text/css" media="screen, projection" />
  <link rel="stylesheet" type="text/css" href="/css/highlight/99_solarized_dark.css" />
  <script src="/js/highlight.pack.js"></script>
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-33950131-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();

    </script>
</head>
<body>
  <div class="site">
    <div class="title">
        <a href="/">槐花九九</a>
        <a class="extra" href="/archive.html">存档</a>
    </div>
    
    
    <div id="post">
    <h1>Laravel Events</h1>
    <p class="meta">16 Aug 2012 - By MiniMee</p>

<p>Event事件类在Laravel框架中是作为核心类在core.php中被载入的，它对于Laravel的松耦合非常重要，今天想写的就是关于Event有关部分。</p>

<pre><code>// laravel/event.php
public static $events = array();
public static $queued = array();
public static $flushers = array();
</code></pre>

<p>我们依旧可以把event类当作是一个容器，同时它还提供了操作容器的工具。event类储存了3个数组：events、queued以及flushers。events储存的是我们监听的事件，queued储存的则是事件队列，flushers储存的是队列事件的响应方法。</p>

<p>监听一个事件的方法很简单：</p>

<pre><code>Event::listen('sayhello',function()
        {
            echo 'Hello!';
        });
</code></pre>

<p>我们监听了一个sayhello事件，其实就是把sayhello事件放到了$events数组中，现在我们来触发事件：</p>

<pre><code>Event::fire('sayhello'); // output : Hello!
</code></pre>

<p>Laravel为我们提供了3种触发事件的方法：</p>

<pre><code>Event::fire('sayhello');
Event::first('sayhello');
Event::until('sayhello');
</code></pre>

<p>如果只触发单个事件，它们的功能是相同的，它们的区别主要在于触发多个事件时的返回结果，我们以监听多个事件的例子来说明。打开application/routes.php,在其他代码前添加如下代码：</p>

<pre><code>// application/routes.php 
// 监听多个事件
Event::listen('event1',function()
        {
            return;
        });
Event::listen('event2',function()
        {
            return 'This is event2.';
        });
Event::listen('event3',function()
        {
            return 'This is event3.';
        });
// 用三种方法分别触发事件
$fire = Event::fire(array('event1','event2','event3'));
$first = Event::first(array('event1','event2','event3'));
$until = Event::until(array('event1','event2','event3'));
// 打印返回结果
var_dump($fire,$first,$until);
// 断点
exit;
</code></pre>

<p>运行Laravel之后我们看到了如下结果：</p>

<pre><code>array(3) { [0]=&gt; NULL [1]=&gt; string(15) "This is event2." [2]=&gt; string(15) "This is event3." } 
NULL 
string(15) "This is event2."
</code></pre>

<p>从对比返回结果我们就会知道三种方法区别所在。fire方法返回了一个包含所有事件返回结果的数组，而first方法则是返回第一个事件的结果，until方法是返回事件执行的第一个非NULL结果。event1返回的是NULL，因此$until得到的是第一个非NULL返回，即event2的返回结果。</p>

<p>Event类还为我们提供了事件队列，使用方法也很简单：</p>

<pre><code>// application/routes.php
Event::queue('foo','event1',array(function(){echo 'This is event1';}));
Event::queue('foo','event2',array(function(){echo 'This is event2';}));
Event::flusher('foo',function($key,$value)
        {
            echo $key.' : ';
            $value();
            echo '&lt;br /&gt;';
        });
Event::flush('foo');
exit;
</code></pre>

<p>在上面的代码中我们创建了一个foo队列，并把event1和event2加入到了队列中，然后为foo队列建立了一个响应方法，最后就是触发队列,运行代码后我们可以到以下结果：</p>

<pre><code>event1 : This is event1
event2 : This is event2
</code></pre>

<p>对于队列我们需要注意到是queue方法的第三个参数必须是数组，至于怎么运用队列那就必须看实际需求了。</p>

<p>最后还要说下的就是几个默认被Laravel框架触发的事件，我标出了它们所在的文件和行数：</p>

<pre><code>// laravel/bundle.php 110行
Event::fire("laravel.started: {$bundle}");
// laravel/database/connection.php 313行     
Event::fire('laravel.query', array($sql, $bindings, $time));
// laravel/laravel.php 189行
Event::fire('laravel.done', array($response));
// laravel/log.php 49行
Event::fire('laravel.log', array($type, $message));
</code></pre>

<p>这几个事件虽然是框架默认触发的事件，但是默认返回的是NULL，因为框架并没有事先监听它们。我把这几个事件理解为laravel默认的钩子，当我们需要的时候，比如Debug时再去监听它们，如果理解有误请指正。</p>
    </div>

    <div id="related">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
                var disqus_shortname = 'minimee'; // required: replace example with your forum shortname

                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
            <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
            

    </div>

    
    <div class="footer"></div>
  </div>
  <a href="http://github.com/zither"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  <script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
