<!doctype html>
<html lang="zh-cn" class="no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta name="description" content="记录在生活以及自学编程过程中好玩的东西。">
	<meta name="keywords" content="MiniThinker, Programming, Computer, PHP, Scheme">
	<title>MiniThinker</title>
	
	<link rel="stylesheet" href="/theme/main.css">
</head>
<body>
	<div id="main">
		<div class="border">
			<header>
				<h1><a href="/">MiniThinker</a></h1>
				<h2>努力学习那些想要知道的东西</h2>
			</header>
			<div id="nav">
				<a href="/">Home</a>
				<a href="/linux">Linux</a>
				<a href="/about">About</a>
			</div>
			<div id="container"><div id="page">
		<article>
		<div class="title">
			<a href="/article/2015/02/12/a-simple-implemention-of-Skcoswodahs-client">Skcoswodahs client 的简单实现</a>		</div>
		<div class="info">
			<span class="date">2015-02-12</span>
			-
			<span class="category">
				Category: <a href="/category/Programming">Programming</a>			</span>
					</div>
		<div class="content">
			<p>现在最热门的上网姿势非 <a href="https://github.com/shadowsocks/shadowsocks">Skcoswodahs</a> 莫属,当初作者发布的时候只是一个非常简单的小工具，但是没想到现在基本达到了全平台覆盖。可能有不少朋友对它的原理感兴趣，这里就让我们使用 PHP 来实现一个简单的 Skcoswodahs 客户端。</p>
<p>首先我们需要知道 Skcoswodahs 在传输数据的时候是分为3个部分，这里我们使用浏览器访问网站的例子来说明：</p>
<pre>
<code>+--------------------------------------------------------------+
|             1                2                 3             |
+  browser ------- ss-local ------- ss-server ------- DST host +
|           socks         Skcoswodahs          socks           |
+--------------------------------------------------------------+</code>
</pre>
<p>从上面我们可以看出，shadowsock 将一个 SOCKS 代理拆分为 local SOCKS（1） 以及 server SOCKS（3） 两个代理，这两个阶段传递的都是原始数据。而 local SOCKS 与 server SOCKS 之间（2）传输的则是经过加密的数据，我们暂且称其为 Skcoswodahs 协议。</p>
<p>在这篇文章中我们要实现的就是 ss-local，它负责接收浏览器发出的 HTTP 请求，然后将请求内容加密后转发到 ss-server。不过为了方便这里我们跳过了 ss-local 与浏览器 SOCKS 握手的 method-dependent 阶段，直接纯手工构建需要传输的数据。如果你并不了解 SOCKS 协议，那么需要先阅读 <a href="https://www.ietf.org/rfc/rfc1928.txt">SOCKS 协议规范</a>。</p>
<p>在浏览器与 ss-local 之间的 method-dependent 协商完成后，浏览器会将需要访问的服务器地址和端口发送给 ss-local，其格式如下：</p>
<pre>
<code> +----+-----+-------+------+----------+----------+
 |VER | CMD |  RSV  | ATYP | DST.ADDR | DST.PORT |
 +----+-----+-------+------+----------+----------+
 | 1  |  1  | X'00' |  1   | Variable |    2     |
 +----+-----+-------+------+----------+----------+</code>
</pre>
<p>ATYP，DST.ADDR 和 DST.PORT 这三个字段（Header）是需要通过我们的客户端转发到 ss-server 的。在我们与 ss-server 连接成功后可以完成与浏览器 SOCKS 协商的剩下部分。浏览器再将 HTTP 请求发送到我们的客户端。我们可以直接将之前的 Header 和 HTTP 请求内容拼接在一起进行加密，然后通过之前建立的连接发送的 ss-server。加密数据的格式如下：</p>
<pre>
<code> +------+----------+----------+----------+
 | ATYP | DST.ADDR | DST.PORT |   HTTP   | 
 +------+----------+----------+----------+
 |  1   | Variable |    2     | Variable |
 +------+----------+----------+----------+</code>
</pre>
<p>需要注意的是，header 部分只需要在建立通道的时候发送一次，通道建立之后直接传递加密的请求数据即可。ss-server 在收到数据后会直接解密，读取 ATYP 字段，根据其类型解析 header 部分，如果数据的整个长度超过 header 的长度，剩下的部分就会作为请求的内容。ss-server 会将从目标服务器获取的数据加密后通过通道转发回我们的客户端，我们需要将数据解密后返回给浏览器。</p>
<p>从整个通信过程来说，我们的客户端其实就是带有加密解密功能的 SOCKS server。除了 SOCKS server 最基本的功能以外，需要我们动手就是加密解密功能了。现在我们开始写代码：</p>
<pre>
<code class="language-php">//source code: https://gist.github.com/zither/e35888cbb98e56f59dd4
require "Encryptor.php";
require "Cipher.php";
require "Rc4crypt.php";

$domain = "www.google.com";
$data = pack("C2", 0x03, strlen($domain));
$data .= $domain . pack("n", 0x50);
$data .= sprintf("GET / HTTP/1.1\r\nHost:%s\r\nAccept:text/html\r\n\r\n", $domain);</code>
</pre>
<p>我们的客户端非常简单，简单到只支持一直加密方式：RC4。Encryptor.php，Cipher.php 和 Rc4crypt.php 这三个文件功能比较简单。Rc4crypt 提供了 RC4 加密方法的原生实现，Cipher 只是对 Rc4crypt 包裹了一下，实现了 Skcoswodahs 使用的 RC4-md5 加密，其实就是每个请求使用不同的 key 而已。Encryptor 的主要作用有两个：一是通过 password 生成加密需要的 key 和 随机 iv 字符串，二是调用 Cipher 对数据进行加密和解密。</p>
<p>我直接跳过了与浏览器协商的部分，我们假设浏览器发出的请求是访问 Google 首页，为了摆出科学的姿势，我们不能在本地对 Domain 进行 DNS 解析，所以 Header 的内容是这样的：</p>
<pre>
<code> +------+------+----------------+----------+
 | ATYP | ALEN |    DST.ADDR    | DST.PORT | 
 +------+------+----------------+----------+
 | 0x03 | 0x0E | www.google.com |   0x50   |
 +------+------+----------------+----------+</code>
</pre>
<p>上面表示的是 ATYP 为完整域名（0x03）时的格式，ALEN 用一个字节指定域名的长度，DST.PORT 用两个字节指定端口。SOCKS 还支持 IP4（0x01）和 IP6（0x04），对应的格式可以直接在 <a href="https://www.ietf.org/rfc/rfc1928.txt">SOCKS 协议规范</a>中了解。为了避免 ss-server 在解析 Header 时出现错误，ATYP,ALEN 以及 DST.PORT 这几个重要的部分我们通过 pack 函数以二进制的形式包装到字符串中。最后我们在 Header 后面附加一个简单的 HTTP 请求，这样我们就完成了一个虚拟请求的数据构成。</p>
<p>现在我们可以将数据进行加密了：</p>
<pre>
<code class="language-php">$encryptor = new Encryptor("password", "RC4");
$encryptedData = $encryptor-&gt;encrypt($data);</code>
</pre>
<p>这里的 password 就是 Skcoswodahs 的配置文件中约定的密码，RC4 是加密方法。这里有一个地方需要注意，在第一次加密数据的时候 Encryptor 会将随机字符串 iv 与我们的数据拼接在一起：</p>
<pre>
<code class="language-php">class Encryptor 
{
    //...
    public function encrypt($data)
    {
        if (strlen($data) == 0) {
            return $data;
        }
        if ($this-&gt;ivSent) {
            return $this-&gt;cipher-&gt;encrypt($data);
        }
        $this-&gt;ivSent = true;
        return $this-&gt;cipherIv . $this-&gt;cipher-&gt;encrypt($data);
    }
    //...
}</code>
</pre>
<p>在我们准备好数据之后就要开始与 ss-server 通信，如果你手上没有 Skcoswodahs 服务器，可以在本地环境中搭建一个，server 地址改为 127.0.0.1 就可以了：</p>
<pre>
<code class="language-json">{
    "server": "127.0.0.1",
    "server_port": "50560",
    "local_address": "127.0.0.1",
    "local_port": "5250",
    "password": "password",
    "timeout": "300",
    "method": "rc4-md5",
    "fast_open": false,
    "workers": 1
}</code>
</pre>
<p>如果你使用的是本地服务器，请将前面代码中的 domain 换为国内能够访问的地址，比如 www.bing.com。数据加密之后我们需要与 ss-server 建立一个通道：</p>
<pre>
<code class="language-php">$remote = stream_socket_client("tcp://example.ss-server.com:50565", $errno, $errstr);
if (!$remote) {
    throw new Exception($errstr, $errno);
}
$send = fwrite($remote, $encryptedData);
printf("Forward %d bytes data to remote.\n", $send);</code>
</pre>
<p>在 PHP 5.0 之后的版本中我们可以直接使用 <code>stream_socket_client</code> 来创建 socket 连接，然后将加密好的数据发送到 ss-server。ss-server 会解密数据再将其转发到目标服务器。我们只需等待 ss-server 的回应即可：</p>
<pre>
<code class="language-php">$encryptedResponse = "";
stream_set_timeout($remote, 1);
while(true) {
    // 在阻塞模式中不能使用 stream_socket_recvfrom，stream_set_timeout 的设置对其无效
    // MTU 一般为 1500
    $buffer = fread($remote, 1500);
    if ("" === $buffer || false === $buffer) {
        break;
    }
    $encryptedResponse .= $buffer;
}
$response = $encryptor-&gt;decrypt($encryptedResponse);
printf(
    "Receive %d bytes data from remote.\nResponse content:\n\n %s\n", 
    strlen($response), 
    $response
);</code>
</pre>
<p>考虑到数据被分片的情况，我们使用无限循环保证读取到所有数据，再使用 Encryptor 解密数据，你应该可以看回应的内容大致为：</p>
<pre>
<code>Forward 91 bytes data to remote.
Receive 526 bytes data from remote.
Response content:

HTTP/1.1 302 Found
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Location: http://www.google.co.jp/?gfe_rd=cr&amp;ei=f27dVNmCGY2nmQW83YBo
Content-Length: 259
Date: Fri, 13 Feb 2015 03:24:47 GMT
Server: GFE/2.0
Alternate-Protocol: 80:quic,p=0.08

&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
&lt;H1&gt;302 Moved&lt;/H1&gt;
The document has moved
&lt;A HREF="http://www.google.co.jp/?gfe_rd=cr&amp;amp;ei=f27dVNmCGY2nmQW83YBo"&gt;here&lt;/A&gt;.
&lt;/BODY&gt;&lt;/HTML&gt;</code>
</pre>
<p>这表明我们已经成功将请求发送到了 Google 的服务器。由于我的 ss-server 服务器在日本，所以 Google 回应了一个 302 跳转。在请求完成之后就可以关闭通道了：</p>
<pre>
<code class="language-php">stream_socket_shutdown($remote, STREAM_SHUT_RDWR);
fclose($remote);</code>
</pre>
<p>到此我们已经完成了一个非常简陋的客户端，它只能纯手工构建请求，并且在完成一次通信之后就退出了，但是这并不重要，重要的是我们了解了它的原理。如果你想要完善这个客户端，可以自己为它补上 SOCKS server 的功能，也可以使用其他开源实现，比如：<a href="https://github.com/clue/php-socks-react"><a href="https://github.com/clue/php-socks-react">https://github.com/clue/php-socks-react</a></a>。</p>		</div>
        	</article>
		<article>
		<div class="title">
			<a href="/article/2015/01/26/how-to-use-simple-qiniu-sdk">Simple Qiniu SDK 使用说明</a>		</div>
		<div class="info">
			<span class="date">2015-01-26</span>
			-
			<span class="category">
				Category: <a href="/category/Programming">Programming</a>			</span>
					</div>
		<div class="content">
			<p>为了解决<a href="http://www.shouhuiben.com">「手绘本」</a>的头像托管问题，前几天重写了一遍 <a href="https://github.com/zither/simple-qiniu-sdk">Simple Qiniu SDK</a>，剔除了上传以外的其他功能。这是吸取了之前的教训：只维护自己用得到的代码。因此现在的 Simple Qiniu SDK 只能用于小文件上传。下面是一个简单的使用示例：</p>
<pre>
<code class="language-php">// Autoload 源码：https://github.com/zither/simple-qiniu-sdk/blob/master/example/Autoload.php
require __DIR__ . "/Autoload.php";
Autoload::addNamespace('Qiniu', dirname(__DIR__) . '/src/Qiniu');
Autoload::register();

$accessKey = 'accessKey';
$secretKey = 'secretKey';
$qiniu = new \Qiniu\Qiniu($accessKey, $secretKey);

$bucket = $qiniu-&gt;getBucket('sketch');
$response = $bucket-&gt;put($_FILES['file']['tmp_name']);
echo $response-&gt;getContent();</code>
</pre>
<p>这次重写我剔除了 Simple Qiniu SDK 中的自动加载函数，所以在使用前你需要自己解决自动加载问题（推荐使用 Composer）。这个示例使用的是默认设置，如果你需要修改七牛的上传策略，可以使用 setPolicy 方法：</p>
<pre>
<code class="language-php">$bucket = $qiuniu-&gt;getBucket('sketch');
// 更多策略参数请参考：http://developer.qiniu.com/docs/v6/api/reference/security/put-policy.html
$bucket-&gt;setPolicy(array(
    'saveKey' =&gt; sprintf("%s.jpg", time()),
    'returnBody' =&gt; '{"key": $(key),"name": $(fname)}',
    'expires' =&gt; 3600
));</code>
</pre>
<p>你不仅可以指定文件保存的名称，还可以设置 \Qiniu\Bucket::EXTR_OVERWRITE 参数来启用 put（更新） 模式：</p>
<pre>
<code class="language-php">$bucket-&gt;put($_FILES['file']['tmp_name'], 'avatar.png', \Qiniu\Bucket::EXTR_OVERWRITE);</code>
</pre>
<p>你可以自定义一些魔术变量，然后以数组的形式传递给 put 方法：</p>
<pre>
<code class="language-php">$bucket-&gt;setPolicy(array(
    // 通过 returnBody 的形式返回魔术变量
    'returnBody' =&gt; '{"key": $(key), "user": $(x:user)}',                  
));
$uploadParams = array(
    // 文件保存名称
    'key' =&gt; 'avatar.png',
    // 自定义魔术变量
    'x:user' =&gt; 'Simple Qiniu SDK'
);
$bucket-&gt;put($_FILES['file']['tmp_name'], $uploadParams);</code>
</pre>
<p>如果你希望采用<a href="http://developer.qiniu.com/docs/v6/api/overview/up/form-upload.html">表单上传模式</a>，你可以使用 getUpToken 方法来获取上传令牌：</p>
<pre>
<code class="language-html">&lt;form action="http://upload.qiniu.com/" method="post" enctype="multipart/form-data"&gt;
    &lt;input name="file" type="file" /&gt;
    &lt;input name="x:user" type="hidden" value="Simple Qiniu SDK"&gt;
    &lt;input name="token" type="hidden" value="&lt;?=$bucket-&gt;getUpToken()?&gt;"&gt;
    &lt;button id="upload" type="submit"&gt;上传到七牛&lt;/button&gt;
&lt;/form&gt;</code>
</pre>
<p>以上就是重构后 Simple Qiniu SDK 所有功能的使用说明，如果你还需要「删除文件」等其他功能，可以自行修改或者使用<a href="http://developer.qiniu.com/docs/v6/sdk/php-sdk.html">官方 SDK</a>。当然，如果我也有了对应的使用需求，也会给 Simple Qiniu SDK 增加对应的功能支持。 </p>		</div>
        	</article>
		<article>
		<div class="title">
			<a href="/article/2015/01/14/Y-combinator-in-php">Y combinator in PHP</a>		</div>
		<div class="info">
			<span class="date">2015-01-14</span>
			-
			<span class="category">
				Category: <a href="/category/Programming">Programming</a>			</span>
					</div>
		<div class="content">
			<pre>
<code class="language-php">$Y = function($f){
    $x = function($s) use($f){
        return function($n) use($s, $f){
            return $f($s($s))-&gt;__invoke($n);
        };
    };
    return $x($x);
};

$factorial = $Y(function($recurse){
    return function($x) use($recurse){
        return $x === 0 ? 1 : $x * $recurse($x - 1);  
    };         
});

echo $factorial(6); // 720</code>
</pre>
<p>花了一些时间用 PHP 推导了一遍 Y combinator，因为语法上的一些原因，推导过程中总觉得怪怪的。推导结果代码如上所示，精简和美观程度与 LISP 相差甚远，也就勉强能看。</p>		</div>
        	</article>
		<article>
		<div class="title">
			<a href="/article/2014/11/02/update-virtualbox-guest-additions">手动更新 VirtualBox Guest Additions</a>		</div>
		<div class="info">
			<span class="date">2014-11-02</span>
			-
			<span class="category">
				Category: <a href="/category/Vagrant">Vagrant</a>			</span>
					</div>
		<div class="content">
			<p>在使用 Vagrant 作为开发环境一段时间后，发现 Vagrant 也并不能做到完全的无缝迁移。昨天更新系统软件之后，在运行 Vagrant 时提示了 VirtualBox Guest Additions 版本不匹配的警告。这个问题一般是由 VirtualBox 更新引起的，在我们的 Vagrant 环境中，Guest Additions 版本不同最可能出现的问题就是无法挂载共享文件夹。</p>
<p>上面的问题可以通过升级 Vagrant box 里的 Guest Additions 来解决，升级也可以采用自动和手动两种方式。</p>
<p>Vagrant 的 Vbguest plugin 可以在启动时自动检测 Guest Additions 的版本，如果版本不同则自动更新同步，具体教程可以参考这篇教程：<a href="http://kvz.io/blog/2013/01/16/vagrant-tip-keep-virtualbox-guest-additions-in-sync/">Vagrant Tip: Sync VirtualBox Guest Additions</a>。我测试了一下这个插件，整个更新过程基本上是不需要人为操作，但是由于国内的网络问题，可能在下载新版本 Guest Additions(60MB+) 时需要等待比较长的时间。</p>
<p>不过我最后还是采用了手动更新，因为使用 Vagrant 的目的是尽量不折腾，就没必要在解决由于依赖引起的问题时引入新的依赖隐患。Guest Additions 的介绍和手动更新方法在 VirtualBox 的文档 <a href="https://www.virtualbox.org/manual/ch04.html">Chapter 4. Guest Additions</a> 中写得非常详细了。在这里只是把步骤做一个简单的记录，方便以后需要时查看。</p>
<pre>
<code class="language-bash"># 在 Vagrant box 中安装更新依赖
vagrant@precise32:~$ sudo apt-get install linux-headers-$(uname -r) build-essential dkms
# 下载新版本的 Guest Additions
vagrant@precise32:~$ wget http://download.virtualbox.org/virtualbox/4.3.10/VBoxGuestAdditions_4.3.10.iso
# 挂载镜像
vagrant@precise32:~$ sudo mount VBoxGuestAdditions_4.3.10.iso -o loop,ro /mnt
# 卸载旧版本，可省略
vagrant@precise32:~$ sudo sh /mnt/VBoxLinuxAdditions.run uninstall
# 安装新版本
vagrant@precise32:~$ sudo sh /mnt/VBoxLinuxAdditions.run</code>
</pre>
<p>手动安装的过程也非常简单，但是不论是手动还是自动安装完成之后，启动时都可能会遇到以下这两个问题：</p>
<pre>
<code class="language-bash">Failed to mount folders in Linux guest. This is usually because
the "vboxsf" file system is not available. Please verify that
the guest additions are properly installed in the guest and
can work properly. The command attempted was:

mount -t vboxsf -o uid=`id -u vagrant`,gid=`getent group vagrant | cut -d: -f3` /vagrant /vagrant
mount -t vboxsf -o uid=`id -u vagrant`,gid=`id -g vagrant` /vagrant /vagrant</code>
</pre>
<p>这个问题普遍反映在 Guest Additions 4.3.10 版本中，可以通过这个命令解决：</p>
<pre>
<code class="language-bash">vagrant@precise32:~$ sudo ln -sv /opt/VBoxGuestAdditions-4.3.10/lib/VBoxGuestAdditions \
/usr/lib/VBoxGuestAdditions</code>
</pre>
<p>另外一个问题则表现为在新版安装成功之后依然会提示版本不匹配，VirtualBox 检测到的仍然是已经卸载掉的旧版本。首先需要确认新版本已经安装成功，检测是否已经安装了 vboxguest ：</p>
<pre>
<code>vagrant@precise32:~$ lsmod | grep -i vbox
vboxsf                 42523  1 
vboxguest             219244  2 vboxsf
vboxvideo              12550  0 
drm                   197692  1 vboxvideo</code>
</pre>
<p>查看 vboxguest 版本：</p>
<pre>
<code class="language-bash">vagrant@precise32:~$ modinfo vboxguest
filename:       /lib/modules/3.2.0-23-generic-pae/updates/dkms/vboxguest.ko
version:        4.3.10
license:        GPL
description:    Oracle VM VirtualBox Guest Additions for Linux Module
author:         Oracle Corporation
srcversion:     FDAC0A8218FE4AEFD8732E8
alias:          pci:v000080EEd0000CAFEsv00000000sd00000000bc*sc*i*
depends:        
vermagic:       3.2.0-23-generic-pae SMP mod_unload modversions 686 </code>
</pre>
<p>查看 guestproperty 中的版本号（id 可以在项目目录的 .vagrant/machines/default/virtualbox/id 中查看）：</p>
<pre>
<code class="language-bash">MiniThinker@localhost:~$ VBoxManage guestproperty get &lt;id&gt; /VirtualBox/GuestAdd/Version
Value: 4.2</code>
</pre>
<p>前面确认已经成功安装新版本，VBoxManage 仍然检测到的是旧版本，手动设置更新版本号：</p>
<pre>
<code class="language-bash">MiniThinker@localhost:~$ VBoxManage guestproperty set &lt;id&gt; /VirtualBox/GuestAdd/Version</code>
</pre>
<p>在问题解决后重新打包整个环境即可，如果不怕麻烦的话，可以卸载和删掉更新过程中安装和下载的文件。</p>		</div>
        	</article>
		<article>
		<div class="title">
			<a href="/article/2014/10/13/youdao-firefox-alpha">Youdao firefox alpha</a>		</div>
		<div class="info">
			<span class="date">2014-10-13</span>
			-
			<span class="category">
				Category: <a href="/category/Firefox">Firefox</a>			</span>
					</div>
		<div class="content">
			<p>Chromium 升级到版本 37 后在 linux 下的变现欠佳。特别是在字体方面，就算在 Chromium 中设置了相关的字体，也不能完全得到改善。不过 Firefox 32 的表现却与之相反，启动速度、浏览器界面与字体渲染都令人非常满意，所以在 Chromium 相关问题未得到解决的情况下，我会将 Firefox 作为默认浏览器。之前在 Chromium 中使用的大部分插件也有对应的 Firefox 版本，没有迁移障碍。不过翻译插件的迁移就没有那么顺利了。</p>
<p>之前在 Chromium 中主要使用有道词典的划词插件以及网友开发的 Halo 词典，这两者都没有对应的 Firefox 版本。Firefox 自身的翻译插件基本上都是基于 Google 翻译，以目前的网络环境来看，没翻墙的情况下差不多都已残废。我在 Firefox 插件列表中找到了一个叫 Youdao-firefox 的翻译插件，界面和快捷键还比较适合，但是试用的时候发现无法会出现无法翻译的问题，把插件解包了大致看了一下源代码，它依然使用的是 Google 翻译的接口，这是几个意思啊？</p>
<p>既然没能找到好用的翻译插件，那就只能自己动手了，<a href="https://github.com/zither/youdao-firefox">Youdao-firefox-alpha</a> 就这样诞生了。我在 Youdao-firefox 的基础上，将 Google 翻译接口调整为有道词典的接口，删掉了仅对 Google 有用的多语言翻译配置，以及除中英以外的其他国际化支持。在界面和快捷键上仍然与原版一致，在选中单词过后按下 alt + z 就会弹出翻译框。暂时我只添加了有道翻译的基本释意，所以在翻译结果中不能看到网络释意，以后是否会支持还未决定。</p>
<p>插件包不准备放到官方网站上去，所以如果你也需要的话可以在 <a href="https://github.com/zither/youdao-firefox/releases">Github</a> 上下载已经打包好的插件。当然，你也可以 fork 之后增加自己需要的功能，然后重新打包。</p>		</div>
        	</article>
		<div class="bar">
		<span class="new">
					</span>
		<span class="old">
			<a href="/page/2">Older Posts >></a>		</span>
		<span class="count">
			1 / 5		</span>
	</div>
</div>
</div>
			<footer>Powered By <a href="https://github.com/scarwu/Pointless">Pointless</a></footer>
		</div>
	</div>
	<!-- Define and Load Javascript -->
    <script src="http://cdn.staticfile.org/jquery/2.1.1/jquery.min.js"></script>
	<script src="/theme/main.js"></script>
	</body>
</html>
