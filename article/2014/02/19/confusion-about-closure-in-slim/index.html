<!doctype html>
<html lang="zh-cn" class="no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=device-width,initial-scale=1">
	<meta name="description" content="记录在生活以及自学编程过程中好玩的东西。">
	<meta name="keywords" content="MiniThinker,Programming, Computer, PHP, Scheme">
	<title>Slim 中关于 Closure 的问题 | MiniThinker</title>
	
	<!-- Load Cascading Style Sheets -->
	<link rel="stylesheet" href="/theme/main.css">
</head>
<body>
	<div id="main">
		<div class="border">
			<header>
				<h1><a href="/">MiniThinker</a></h1>
				<h2>努力学习那些想要知道的东西。</h2>
			</header>
			<div id="nav">
				<a href="/">Home</a>
				<a href="/about">About</a>
			</div>
			<div id="container"><div id="article">
	<article>
		<div class="title">Slim 中关于 Closure 的问题</div>
		<div class="info">
			<span class="date">2014-02-19</span>
			-
			<span class="category">
				Category: <a href="/category/PHP">PHP</a>			</span>
			-
			<span class="tag">
				Tag: 
								<span><a href="/tag/Slim">Slim</a></span>
							</span>
					</div>
		<div class="content"><p>在翻译 Slim 框架文档的依赖注入（Dependency Injection）部分时发现一个可能会让人迷惑的地方。Slim 框架的所有变量都储存在 \Slim\Helper\Set 类的实例中，我们可以像平常一样向 Slim 中注入需要的变量。但是在注入 Closure 变量时就会和想象中不太一样。这里直接使用用官方文档中的例子来说明：</p>

<!--more-->

<pre><code>$app = new \Slim\Slim();
$app-&gt;uuid = function(){
    return exec('uuidgen');
};
// 获取一个新的 UUID
$uuid = $app-&gt;uuid;
</code></pre>

<p>在这个例子中，我们把一个匿名函数赋值给了名为 uuid 的变量，通常我们需要手动调用这个匿名函数：</p>

<pre><code>// 实例变量不能通过 $app-&gt;uuid(); 方法调用
$uuid = $app-&gt;uuid;
$uuid();
</code></pre>

<p>但是在 Slim 中不需要手动调用，它在 \Slim\Helper\Set 类中使用了自动调用：</p>

<pre><code>public function get($key, $default = null)
{
    if ($this-&gt;has($key)) {
        // 检测变量是否可以调用
        $isInvokable = is_object($this-&gt;data[$this-&gt;normalizeKey($key)]) &amp;&amp; 
            method_exists($this-&gt;data[$this-&gt;normalizeKey($key)], '__invoke');

        return $isInvokable ? 
            // 直接调用
            $this-&gt;data[$this-&gt;normalizeKey($key)]($this) : 
            $this-&gt;data[$this-&gt;normalizeKey($key)];
    }
    return $default;
}
</code></pre>

<p>如果我们需要存储原始的匿名函数，则必须使用 \Slim\Helper\Set 的 protect 的方法。这虽然节省了一些操作代码，但是在不了解 Slim 的情况下会带来一些麻烦。</p>
</div>
	</article>
	<div class="bar">
		<span class="new">
					</span>
		<span class="old">
			<a href="/article/2014/02/17/what-is-a-programming-language">编程语言从哪里来 >></a>		</span>
		<span class="count">&lt; 1 / 3 &gt;</span>
	</div>
	</div>
</div>
			<footer>Powerd By Pointless</footer>
		</div>
	</div>
	<!-- Define and Load Javascript -->
	<script src="/theme/main.js"></script>
	</body>
</html>
